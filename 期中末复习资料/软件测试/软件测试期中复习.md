# 软件测试

> 作者：cqq
>
> 时间：2024-05-11



## 考试题型

1. 填空（10×1‘）
2. 名词解释（4×5‘）
3. 简答（5×6‘）
4. 综合（4×10‘）



说明：

- 加粗部分为知识点的核心（用于快速浏览）
- ”★“表示为考点，”★★“表示必考



## 第二章	软件测试的基本概念

1. 软件缺陷★

   - 定义：软件缺陷是指计算机或系统存在的任何一种**破坏正常运行能力**的问题、错误或隐藏的功能缺陷，瑕疵，其结果会导致软件产品在某种程度上**不能满足用户需求**。
     * 从产品内部看，软件缺陷是软件产品**开发**或**维护**过程中所存在的**错误**、**毛病**等各种问题；
     * 从外部看，软件缺陷是系统所需要实现的某种**功能的失效或违背**。
   - 来源：
     - **技术问题**：算法错误，语法错误，计算和精度问题，接口参数传递不匹配。

     - **团队工作**：沟通不充分，误解。

     - **软件本身**：①文档错误；②用户使用场合；③时间上不协调、或不一致性所带来的问题；④系统的自我恢复或数据的异地备份、灾难性恢复等问题。

2. 软件测试★

   - 定义：使用**人工或自动手段**，来运行或测试某个系统的过程。其目的在于检验它**是否满足规定的需求**或弄清**预期结果与实际结果之间的差别**。
   - 目的：①提高软件的质量；②保证软件的安全；③降低软件开发成本；④降低企业风险；⑤提升用户体验感。

3. 软件测试的分类

   - 按测试层次（阶段）分类★
     - 单元测试（底层层次）：验证**软件单元**（组件/模块/类/函数）是否符合软件需求与设计，开发人员自测。
     - 集成测试（接口层次）：将已经测试过的软件单元组合在一起测试它们**之间的接口**，用于验证软件是否满足设计需求。
     - 系统测试（系统层次）：将经过测试的软件在**实际环境中**运行，并与其他系统的成分（如数据库、硬件和操作人员等）**组合**在一起进行测试。
     - 验收测试（业务/用户层次）：主要是对**软件产品说明**进行验证，逐行逐字的按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。
     - α测试：软件**上线之前**进行的版本测试。由**开发人员和测试人员**或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题，整个测试过程是**可控**的。
     - β测试：软件**上线之后**进行的版本测试。由**用户**在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。
   - 按测试技术分类★
     - 黑盒测试：**基于需求**的测试方法，把软件（程序）当作一个**有输入与输出的黑匣子**，它把程序当作一个输入域到输出域的映射，只要输入的数据能**输出预期的结果**即可，不必关心程序内部是怎么样实现的。
       - 具体方法：①等价类划分法；②边界值分析法；③判定表方法；④因果图法；⑤成对（Pairwise）方法；⑥正交试验法；⑦场景法；⑧状态迁移法。
     - 白盒测试：**结构化**测试方法，测试人员了解软件程序的**逻辑结构、路径与运行过程**，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件 （程序）当作一个**透明的盒子**， 测试人员清楚的知道从输入到输出的**每一步过程**。
       - 具体方法：①语句覆盖；②判定覆盖；③条件覆盖；④判定条件覆盖；⑤条件组合覆盖；⑥基本路径覆盖。

   - 按软件质量特性分类：①功能测试；②性能测试
   - 按自动化程度分类：①手工测试；②自动化测试
   - 按测试项目分类：①界面类测试；②安全性测试；③文档测试
   - 按测试时程序是否运行分类：①静态测试；②动态测试



## 第三章	软件测试方法

1. 黑盒测试

   - 优缺点
     - 优点：①比较**简单**，不需要了解程序内部的代码及实现；②**与软件的内部实现无关**；③**从用户角度出发**，能很容易的知道用户会用到哪些功能，会遇到哪些问题；④**基于软件开发文档**， 所以也能知道软件实现了文档中的哪些功能；⑤在做**软件自动化测试**时较为**方便**。
     - 缺点：①不可能覆盖所有的代码，**覆盖率较低**， 大概只能达到总代码量的 30%；②**自动化测试**的**复用性较低**。

   - 等价类划分法★★

     - 定义：是把所有可能的输入数据，即程序的**输入域划分成若干部分（子集）**，然后从每一个子集中选**取少数具有代表性的数据**作为测试用例。

     - 划分规则

       | 输入数据类型       | 划分等价类规则                                               |
       | ------------------ | ------------------------------------------------------------ |
       | 数据个数           | 1个有效等价类：正确数据的个数；2个无效等价类：大于和小于数据的个数 |
       | 集合               | 1个有效等价类：正确数据集合；1个或多个无效等价类             |
       | 符合某些规则的输入 | 多个有效等价类；若干个无效等价类                             |
       | 取值范围           | 1个有效等价类：正确取值范围；2个无效等价类：大于和小于取值范围 |
       | 布尔值             | 1个有效等价类：TRUE；1个无效等价类：FALSE                    |

     - 步骤：

       1. 分析需求，确定输入数据类型
       2. 使用规则划分有效等价类和无效等价类
       3. 设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类）
       4. 设计用例，覆盖无效等价类（一条用例只能覆盖一个无效等价类）

     - 实例：

       ![](assets\等价划分法实例1.png)

       ![等价划分法实例2](assets\等价划分法实例2.png)

       ![等价划分法实例3](assets\等价划分法实例3.png)

   - 边界值分析法★

     - 定义：是一种黑盒测试方法，旨在测试输入或输出的**边界值**。这种方法通常作为**等价类划分法的补充**，其测试用例选取自等价类的边界。边界值分析的基本思想是在输入变量的**最小值、略高于最小值、正常值、略低于最大值和最大值**处取样，以此来验证系统。

     - 边界值确定：**开内闭外**（开区间取范围内，闭区间取范围外），确定上点、内点、离点

       ![边界值分析法边界值确定](assets\边界值分析法边界值确定.png)

     - 步骤：

       1. 分析需求，确定输入数据类型
       2. 使用规则划分有效等价类和无效等价类
       3. 确定上点、离点、内点
       4. 设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类）
       5. 设计用例，覆盖无效等价类（一条用例只能覆盖一个无效等价类）

     - 实例

       说明：三角形边长取值范围为1-100，因此在设计测试用例时，分别选取1、2、50、99、100

       ![边界值分析法实例](assets\边界值分析法实例.png)

   - 判定表法

     - 定义★：判定表是**分析和表达多逻辑条件**下执行不同操作的情况的工具。
     - 要素★：
       1. **条件桩**：列出问题得所有条件。通常认为列出的条件次序无关紧要。
       2. **动作桩**：列出问题规定可能采取的操作。这些操作的排列顺序没有约束。
       3. **条件项**：列出针对它左列条件的取值。在所有可能情况下的真假值。
       4. **动作项**：列出在条件项的各种取值情况下应该采取的动作。
       5. 规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。判定表中列出多少组条件取值,也就有多少条规则。
     - 步骤：
       1. 定义条件桩与动作桩
       2. 设计和优化判定表
       3. 填写动作项
       4. 简化判定表
       5. 抽取用例（每条规则对应一个用例）

   - 因果图法

     - 定义★：是一种利用**图解法**分析输入的**各种组合**情况，从而设计测试用例的方法，它适合于**检查程序输入条件的各种组合**情况。
     - 步骤：
       1. 分析需求，获取条件和动作
       2. 分析条件与条件、条件与动作之间的关系
       3. 通过关系画出因果图
       4. 将因果图转换为判定表

   - 成对测试：使用PICT

   - 正交实验★

     ![正交实验法](assets\正交实验法.png)

   - 场景法★★

     - 定义：场景法也叫**流程图**法，是指通过**模拟用户操作软件**时的场景来对系统的**功能或业务流程**进行测试

     - 基本概念

       1. **基本流**：也称为有效流，用来模拟用户正确的操作流程
       2. **备选流**：也称为无效流、错误流，用来模拟用户错误的操作流程。

     - 步骤：

       1. 分析需求，找到基本流和备选流
       2. 根据基本流和备选流找到场景（2个要求：①要求从开始到结束才算一个场景；②找全场景标准：所有路径被覆盖）
       3. 每个场景就是一条用例

     - 实例

       ![场景法实例1](assets\场景法实例1.png)

       ![场景法实例2](assets\场景法实例2.png)

       ![场景法实例3](assets\场景法实例3.png)

       ![场景法实例4](assets\场景法实例4.png)

       ![场景法实例5](assets\场景法实例5.png)

   - 状态迁移法★

     - 定义：状态迁移图被用来描述**系统或对象的状态**，以及导致系统或对象的状态**改变**的事件，从而描述系统的行为。属于结构化分析方法使用工具。

     - 步骤：

       1. 明确状态节点
       2. 绘制状态迁移图
       3. 绘制状态迁移树
       4. 抽取路径设计用例

     - 实例

       ![状态迁移图法实例1](assets\状态迁移图法实例1.png)

       ![状态迁移图法实例2](assets\状态迁移图法实例2.png)

       ![状态迁移图法实例3](assets\状态迁移图法实例3.png)

       ![状态迁移图法实例4](assets\状态迁移图法实例4.png)

       ![状态迁移图法实例5](assets\状态迁移图法实例5.png)

   - 错误推测法

     - 定义：是指在测试程序时，人们可以根据**经验或直觉**推测程序中可能存在的各种错误，从而有**针对性**地编写检查这些错误的测试用例的方法。

2. 白盒测试

   - 优缺点：
     - 优点：帮助软件测试人员**增大代码的覆盖率**， 提高代码的质量，发现代码中**隐藏的问题**。
     - 缺点：程序运行会有很多不同的路径，**不可能测试所有的运行路径**；测试基于代码，只能测试开发人员做的对不对，而**不能知道设计的正确与否**，可能**会漏掉一些功能需求**；系统庞大时，**测试开销会非常大**。

   - 语句覆盖法

     - 要求★：程序中每条语句至少被执行一次

     - 局限性：①在六种逻辑覆盖标准中，语句覆盖标准**最弱**；②语句覆盖不能准确判断运算中的**逻辑关系错误**。

     - 实例

       ![语句覆盖法实例](assets\语句覆盖法实例.png)

   - 判定（分支）覆盖法

     - 要求★：每个判断的”真“和”假“都至少被执行一次，即程序中的**每个分支至少执行一次**。

     - 注意：只要满足了判定覆盖标准就**一定满足语句覆盖标准**。

     - 局限性：判定覆盖会**忽略条件中取或（or）的情况**

     - 实例

       ![判定覆盖法实例](assets\判定覆盖法实例.png)

   - 条件覆盖法

     - 要求★：判定中的每个条件至少有一次取真值，有一次取假值。

     - 说明：条件覆盖比判定覆盖增加了对判定中所有条件的测试。

     - 局限性：条件覆盖并**不能保证判定覆盖**。

     - 实例

       ![条件覆盖法实例](assets\条件覆盖法实例.png)

   - 判定条件覆盖法

     - 要求★：每个判断本身的判定结果（真假）至少满足一次，每个逻辑条件的可能值（真假）也至少被满足一次（**100%判定覆盖+100%条件覆盖**）。

     - 注意：满足判定条件覆盖标准**一定满足条件覆盖、判定覆盖和语句覆盖**。

     - 局限性：判定条件覆盖会**忽略条件中取或（or）的情况**。

     - 实例

       ![判定条件覆盖法实例1](assets\判定条件覆盖法实例1.png)

       ![判定条件覆盖法实例2](assets\判定条件覆盖法实例2.png)

   - 条件组合覆盖法

     - 要求★：被测试程序中的每个判定中的条件结果的**所有可能组合**至少执行一次。

     - 注意：条件组合覆盖能**满足判定覆盖、条件覆盖、判定条件覆盖、语句覆盖**

     - 局限性：**不能保证所有路径**被执行。

     - 实例

       ![条件组合覆盖法实例](assets\条件组合覆盖法实例.png)

   - 路径覆盖法

     - 要求★：覆盖程序中所有可能的路径。

     - 说明：路径覆盖可以对程序进行彻底的测试，比前五种覆盖**都广**。

     - 局限性：虽然满足路径覆盖&判定覆盖，但**不一定满足条件覆盖**，也就**不一定满足条件组合覆盖**

     - 实例

       ![路径覆盖法实例](assets\路径覆盖法实例.png)

   - 基本路径测试法★★

     - 定义：路径覆盖是指设计若干个测试用例，运行被测程序，使程序的**每条可能路径都至少执行一次**。路径覆盖是**覆盖率最高**的一种覆盖技术。

     - 计算环路（圈）复杂度

       1. 流图中区域的数量对应于环形的复杂性
       2. 给定流图G的圈复杂度V(G)，$V(G)=E-N+2$。其中$E$为边数，$N$为节点数
       3. 给定流图G的圈复杂度V(G)，$V(G)=P+1$。其中$P$为判定节点数

     - 步骤：

       1. 根据代码画出程序控制流程图
       2. 计算程序的环路复杂度
       3. 导出可执行路径
       4. 设计测试用例

     - 实例

       ![基本路径测试法实例1](assets\基本路径测试法实例1.png)

       ![基本路径测试法实例2](assets\基本路径测试法实例2.png)

       ![基本路径测试法实例3](assets\基本路径测试法实例3.png)

       ![基本路径测试法实例4](assets\基本路径测试法实例4.png)



## 第四章	软件测试流程和规范

1. 敏捷测试★

   - 定义：测试的一种, 主张尽早开始测试， 重点关注**持续迭代地测试**新开发的功能。敏捷的测试团队还要保证整个软件开发过程**是正确的是符合用户需求的**。

   - 特点：

     - **更强的协作**：敏捷开发人员和测试人员工作得更加紧密，喜欢更直接的沟通方式而不是通过邮件文档这种一来一回反反复复的沟通模式;

     - **更短的周期**：需求验证或测试的时间不再是按月来计算，而是按天甚至按小时计算。用户验收测试在每个 sprint 的结尾都会进行;

     -  **更灵活的计划**：敏捷测试也需要拥抱变化， 测试计划不再是一成不变的文档，而会根据业务价值交付的顺序进行灵活的调整;

     -  **更高效的自动化**：相比传统测试， 自动化在敏捷测试中扮演了极其重要的角色。它是实现快速交付确保质量的一种非常有效的手段。

   - 作用：①缩短价值交付周期；②更早发现测试风险；③强调质量属于大家；④化繁为简节省成本

2. 测试用例八要素★

   1. **用例编号**：用例的唯一标识。由字符和数字组成的字符串，具有唯一性，易识别性。
   2. 测试项目：用例的所属项目范畴。
   3. 测试标题：用例的简要描述。体现测试出发点关注点以及测试用例期盼的测试结果。
   4. 重要级别（优先级别）：用例的重要程度影响。重要级别一般分为高中低。
   5. 预置条件：用例执行的前提。测试用例在执行时需要满足一些前提条件，环境的设置。
   6. **测试输入**：测试用例数据输入。测试执行中需要加工的外部信息，避免用描述性语言，要具体，根据测 试用例具体情况，有手工输入， 文件，数据库记录。
   7. 操作步骤：执行用例的步骤。执行当前用例需要经过的操作步骤，需要明确的给出每一个步骤的描述。
   8. **预期结果**： 应该得到的结果。需要判断测试对象是否正常工作。

3. 软件测试过程★

   1. 分析测试**需求**
   2. 制定测试**计划**
   3. 设计测试**用例**
   4. **执行**测试
   5. 提交bug
   6. 编写测试**报告**
   7. 上线维护



## 第五章	单元测试与集成测试

1. 常见的集成测试策略

   - 一次性集成方式
   - 增值式集成方式
     - 自顶向下增值方式
     - 自底向上增值方式
     - 混合增值方式

2. 一次性集成方式★

   - 定义：是一种**非增殖式**集成方式。使用这种方式，首先对每个模块**分别进行模块测试**，然后再把所有模块**组装**在一起进行测试，最终得到要求的软件系统。

   - 缺点：错误难以诊断定位

     ![一次性集成方式](assets\一次性集成方式.png)

3. 增值式集成方式★

   - 定义：又称**渐增式集成方式**。首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中**边连接边测试**，以发现连接过程中产生的问题。最后组装成为要求的软件系统。

   - 自顶向下增值方式

     - 说明：可以采取**深度**优先或**广度**优先策略。

     - 实例

       ![深度优先的集合测试](assets\深度优先的集合测试.png)

       ![广度优先的集成测试](assets\广度优先的集成测试.png)

   - 自顶向下增值方式

     ![自底向上增值方式](assets\自底向上增值方式.png)



## 补充部分

1. α测试和β测试的区别★

   - **测试的场所不同**：α测试是指**把用户请到开发方的场所**来测试，β测试是指**在一个或多个用户的场所**进行测试。
   - **测试环境不同**：α测试的环境受开发方控制的**用户的数量相对较少**，**时间比较集中**。而β测试的环境是不受开发方控制的，谁也不知道用户如何折磨软件，**用户数量相对较多**，**时间不集中**。
   - **测试周期的不同**：一般地，**α测试先于β测试**执行通用软件产品需要较大规模的β测试，**测试周期较长**。

2. 回归测试★

   - 定义：回归测试是指修改了旧代码后，重新进行测试以确认修改**没有引入新的错误**或**导致其他代码产生错误**的一种测试方法。

     -  回归测试是指**重复以前的全部或部分**的相同功能测试

     -  新加入测试的模块，可能对其他模块产生**副作用**，因此要进行某些程度的回归测试
     - 回归测试的重心，是**以关键性模块为核心**

3. 测试报告的内容★

   - 测试结论（是否达到发布标准， 是否可发布）

   - 已知风险、未知风险

   - 测试时间， 测试人员（测试起止时间）

   - 测试环境， 测试设备（用到哪些测试数据，客户端环境， 浏览器）

   - 需求大纲（当前这个版本，包含哪些需求点）

   - Bug 数据分析（从多个维度分析：bug 等级分布，遗留 bug 分析，bug 类型分布。模块 bug 分布， bug 激活次数分析）

   - 测试总结（从测试角度， 对版本存在的问题， 提出建议）

4. 测试结束的标准★

   - 模块测试用例执行完毕，**覆盖全部软件需求**
   - 缺陷**收敛趋势**符合质量要求
   - 缺陷**修复率**达到产品设计人员的需求
   - 达到预先的**缺陷度量原则**（缺陷密度值达到客户的要求）